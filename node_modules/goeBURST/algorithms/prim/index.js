var unionfind = require('union-find')
var heap = require('heap');

var CompmissingChar = '';

function hamming(p, q) {
  var res = 0;
  for (var i = 0; i < p.length; i++)
    if (p[i] != q[i])
      res = res + 1;
  return [res, 0];
}

function hammingMissing(p, q) {
  var res = 0;
  var missings = 0;
  for (var i = 0; i < p.length; i++)
    if (p[i] != q[i] && p[i] != CompmissingChar && q[i] != CompmissingChar)
      res = res + 1;
    else if(p[i] == CompmissingChar || q[i] == CompmissingChar)
      missings = missings + 1;
  return [res, missings];
}

function filter_profile(profiles, identifiers, missings, analysis_method, threshold, callback){

  var indexToRemove = {};

  if(missings[0] == true && analysis_method != 'pairwise' && analysis_method != 'pair+tie'){
    var newProfiles = [];
    var newProfile = [];
    indexToRemove = {};
    threshold_counter = {};
    core_counter = {};

    //Removing missing data columns from profiles
    for(var i=0; i<profiles.length; i++){
      for (var j = 0; j < profiles[i].length; j++){
        if(profiles[i][j] == missings[1]){
          if(!threshold_counter.hasOwnProperty(j)) threshold_counter[j] = 0;
          threshold_counter[j] += 1;
        }
        else{
          if(!core_counter.hasOwnProperty(j)) core_counter[j] = 0;
          core_counter[j] += 1;
        }
        if(threshold_counter[j]/profiles.length >= threshold) indexToRemove[j] = true;
        if(analysis_method == 'pres-abs' && core_counter[j] == profiles.length) indexToRemove[j] = true;
      }
    }
    console.log("PROFILES LENGTH", profiles.length);
    console.log(analysis_method, Object.keys(indexToRemove).length);

    for(var i=0; i<profiles.length; i++){
      newProfile = [];
      for (var j = 0; j < profiles[i].length; j++){
        if(indexToRemove.hasOwnProperty(j) == false){
          newProfile.push(profiles[i][j]);
        }
      }
      newProfiles.push(newProfile);
    }
    profiles = newProfiles;

    if(analysis_method == 'pres-abs'){
      var mc = '0'
      threshold_counter = {};

      if(missings[1] != ''){
        mc = missings[1];
      }
      //Changing values to presence/absence (0/1)
      for(var i=0; i<profiles.length; i++){
        for (var j = 0; j < profiles[i].length; j++){
          if(profiles[i][j] != mc){
            profiles[i][j] = '1';
          }
          else profiles[i][j] = '0';
        }
      }
      callback(indexToRemove, profiles);
    }
    else callback(indexToRemove, profiles);
  }
  else callback(indexToRemove, profiles);
}

function goeBURST_prim(profiles, identifiers, missings, analysis_method, threshold, callback) {

  
  filter_profile(profiles, identifiers, missings, analysis_method, threshold, function(indexToRemove, profiles){

    lvs = profiles.map(function(x){
      return x.map(function(x){return 0;});
    });
   
    var pi = [];
    var color =[];
    var hammingValues= {};
    var comparator = '';

    console.log(analysis_method);

    if(missings[0] == true && analysis_method == 'pairwise' || analysis_method == 'pair+tie'){
      comparator = hammingMissing;
      CompmissingChar = missings[1];
    }
    else comparator = hamming;

    var distanceMatrix = [];
    var maxDistance = -1;

    //profiles.map(function(x){
    //  return profiles.map(function(y){return 0;});
    //});
    console.log('number of profiles', profiles.length);
    
    for (var i = 0; i < profiles.length; i++)
      color[i] = 0;

    for (var i = 0; i < profiles.length-1; i++) {
      distanceMatrix.push([0]);
      for (var j = i+1; j < profiles.length; j++) {
        var diff = comparator(profiles[i], profiles[j]);
        distanceMatrix[i].push(diff[0]);
        if(diff > maxDistance) maxDistance = diff[0];
        lvs[i][diff[0]] ++;
        lvs[j][diff[0]] ++;
      }
    }

    tree = [];
    var pqueue = new heap(function(a, b) {
      return edgecmp(pi[a], pi[b]);
    });
    pqueue.push(0);
    color[0] = 1;

    while (! pqueue.empty()) {
      var u = pqueue.pop();
      color[u] = 2;
      if (u != 0){
        tree.push({source: identifiers[pi[u][0]], target: identifiers[pi[u][1]], value: comparator(profiles[pi[u][0]], profiles[pi[u][1]])[0]});
      }

      for (var v = 0; v < profiles.length; v++) {

        if (color[v] == 0) {
          color[v] = 1;
          pi[v] = [u,v];
          pqueue.push(v);
        } else if (color[v] == 1 && edgecmp([u,v], pi[v]) < 0) {
          pi[v] = [u,v];
          pqueue.updateItem(v);
        }
      }
    }
    console.log("RESULTS", profiles.length, distanceMatrix.length);

    callback(tree, distanceMatrix, profiles, indexToRemove, maxDistance);

    /////////////////////////////////////////////////////////////

    function edgecmp(e, f) {

      var elevel = comparator(profiles[e[0]], profiles[e[1]]);
      var flevel = comparator(profiles[f[0]], profiles[f[1]]);

      var n = lvs[e[0]].length;

      if (elevel[0] != flevel[0])
        return elevel[0] - flevel[0];

      
      for (var l = 0; l < n; l++) {
        maxe = Math.max(lvs[e[0]][l], lvs[e[1]][l]);
        maxf = Math.max(lvs[f[0]][l], lvs[f[1]][l]);

        if (maxe != maxf)
          return maxf - maxe;

        mine = Math.min(lvs[e[0]][l], lvs[e[1]][l]);
        minf = Math.min(lvs[f[0]][l], lvs[f[1]][l]);

        if (mine != minf)
          return minf - mine;
      }

      if (analysis_method == 'pair+tie'){
        //New rule for missing data count
        console.log('entering');
        if(elevel[1] != flevel[1])
          return elevel[1] - flevel[1];
      }

      maxe = Math.max(e[0], e[1]);
      maxf = Math.max(f[0], f[1]);

      if (maxe != maxf)
        return maxe - maxf;

      mine = Math.min(e[0], e[1]);
      minf = Math.min(f[0], f[1]);

      return minf - mine;
    }

  });

}

module.exports = goeBURST_prim;
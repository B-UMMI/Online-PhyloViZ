var unionfind = require('union-find')
var heap = require('heap');

var CompmissingChar = '';

function hamming(p, q) {
  var res = 0;
  for (var i = 0; i < p.length; i++)
    if (p[i] != q[i])
      res = res + 1;
  return res;
}

function hammingMissing(p, q) {
  var res = 0;
  for (var i = 0; i < p.length; i++)
    if (p[i] != q[i] && p[i] != CompmissingChar && q[i] != CompmissingChar)
      res = res + 1;
  return res;
}

function filter_profile(profiles, identifiers, missings, analysis_method, callback){

  var indexToRemove = {};
  console.log(missings);

  if(analysis_method == 'pres-abs'){
    var mc = '0'
    if(missings[1] != ''){
      mc = missings[1];
    }
    //Changing values to presence/absence (0/1)
    for(var i=0; i<profiles.length; i++){
      for (var j = 0; j < profiles[i].length; j++){
        if(profiles[i][j] != mc){
          profiles[i][j] = '1';
        }
        else profiles[i][j] = '0';
      }
    }
  }
  else if(missings[0] == true){
    var newProfiles = [];
    var newProfile = [];
    indexToRemove = {};

    //Removing missing data columns from profiles
    for(var i=0; i<profiles.length; i++){
      for (var j = 0; j < profiles[i].length; j++){
        if(profiles[i][j] == missings[1]){
          indexToRemove[j] = true;
        }
      }
    }
    for(var i=0; i<profiles.length; i++){
      newProfile = [];
      for (var j = 0; j < profiles[i].length; j++){
        if(!indexToRemove.hasOwnProperty(j)){
          newProfile.push(profiles[i][j]);
        }
      }
      newProfiles.push(newProfile);
    }
    profiles = newProfiles;
  }
  callback(indexToRemove, profiles);
}

function goeBURST_prim(profiles, identifiers, missings, analysis_method, callback) {

  
  filter_profile(profiles, identifiers, missings, analysis_method, function(indexToRemove, profiles){

    lvs = profiles.map(function(x){
      return x.map(function(x){return 0;});
    });
   
    var pi = [];
    var color =[];
    var hammingValues= {};
    var comparator = '';

    if(missings[0] == true){
      comparator = hammingMissing;
      CompmissingChar = missings[1];
    }
    else comparator = hamming;

    var distanceMatrix = [];

    //profiles.map(function(x){
    //  return profiles.map(function(y){return 0;});
    //});
    for (var i = 0; i < profiles.length; i++)
      color[i] = 0;

    for (var i = 0; i < profiles.length-1; i++) {
      distanceMatrix.push([0]);
      for (var j = i+1; j < profiles.length; j++) {
        var diff = hamming(profiles[i], profiles[j]) - 1;
        distanceMatrix[i].push(diff);
        lvs[i][diff] ++;
        lvs[j][diff] ++;
      }
    }

    tree = [];
    var pqueue = new heap(function(a, b) {
      return edgecmp(pi[a], pi[b]);
    });
    pqueue.push(0);
    color[0] = 1;

    while (! pqueue.empty()) {
      var u = pqueue.pop();
      color[u] = 2;
      if (u != 0){
        tree.push({source: identifiers[pi[u][0]], target: identifiers[pi[u][1]], value: hamming(profiles[pi[u][0]], profiles[pi[u][1]])});
      }

      for (var v = 0; v < profiles.length; v++) {

        if (color[v] == 0) {
          color[v] = 1;
          pi[v] = [u,v];
          pqueue.push(v);
        } else if (color[v] == 1 && edgecmp([u,v], pi[v]) < 0) {
          pi[v] = [u,v];
          pqueue.updateItem(v);
        }
      }
    }

    callback(tree, distanceMatrix, profiles, indexToRemove);

    /////////////////////////////////////////////////////////////

    function edgecmp(e, f) {

      var elevel = hamming(profiles[e[0]], profiles[e[1]]);
      var flevel = hamming(profiles[f[0]], profiles[f[1]]);

      var n = lvs[e[0]].length;

      if (elevel != flevel)
        return elevel - flevel;

      
      for (var l = 0; l < n; l++) {
        maxe = Math.max(lvs[e[0]][l], lvs[e[1]][l]);
        maxf = Math.max(lvs[f[0]][l], lvs[f[1]][l]);

        if (maxe != maxf)
          return maxf - maxe;

        mine = Math.min(lvs[e[0]][l], lvs[e[1]][l]);
        minf = Math.min(lvs[f[0]][l], lvs[f[1]][l]);

        if (mine != minf)
          return minf - mine;
      }
      

      maxe = Math.max(e[0], e[1]);
      maxf = Math.max(f[0], f[1]);

      if (maxe != maxf)
        return maxe - maxf;

      mine = Math.min(e[0], e[1]);
      minf = Math.min(f[0], f[1]);

      return minf - mine;
    }

  });

}

module.exports = goeBURST_prim;
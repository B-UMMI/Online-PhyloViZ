
var utils_object = {
	checkIfpublic: checkIfpublic,
	getNodes: getNodes,
	getLinks: getLinks,
	getMetadata: getMetadata,
	getAux: getAux,
	getPositions: getPositions,
	getNewick: getNewick,
	getDataset: getDataset,
	addToFilterTable: addToFilterTable,
	getFromFilterTable: getFromFilterTable,
	FlushFunction: FlushFunction,
	mergeMetadata: mergeMetadata

}

var config = require('../../config.js');

function checkIfpublic(datasetID, userID, callback){

	var pg = require("pg");
	var connectionString = "postgres://" + config.databaseUserString + "@localhost/"+ config.db;

	//var datasetID;
	var isPublic = false;

	//query = "SELECT id FROM datasets.datasets WHERE dataset_id = '"+datasetID+"' AND user_id=$1;";

	var client = new pg.Client(connectionString);
		client.connect(function(err) {
		  if(err) {
		    return console.error('could not connect to postgres', err);
		  }

		    query = "SELECT name FROM datasets.datasets WHERE dataset_id='"+datasetID+"' AND put_public='t' LIMIT 1;";

		    client.query(query, function(err, result) {
			    if(err) {
			      return console.error('error running query', err);
			    }

				var dataset = {};

				if (result.rows.length > 0){
					isPublic = true;
				}
			    client.end();
			    callback(isPublic);
			});

		});


}


function getNodes(datasetID, userID, isPublic, callback) {

	var pg = require("pg");
	var connectionString = "postgres://" + config.databaseUserString + "@localhost/"+ config.db;

	//var datasetID;

	//query = "SELECT id FROM datasets.datasets WHERE dataset_id = '"+datasetID+"' AND user_id=$1;";

	var client = new pg.Client(connectionString);
		client.connect(function(err) {
		  if(err) {
		    return console.error('could not connect to postgres', err);
		  }
		  if(isPublic == true){
		  	query = "SELECT data AS profiles, schemeGenes FROM datasets.profiles WHERE dataset_id='"+datasetID+"';"+
		  			"SELECT data AS isolates, metadata FROM datasets.isolates WHERE dataset_id='"+datasetID+"' LIMIT 1;" +
		  			"SELECT key FROM datasets.datasets WHERE dataset_id='"+datasetID+"' LIMIT 1;" +
		  			"SELECT data AS links FROM datasets.links WHERE dataset_id='"+datasetID+"' LIMIT 1;";;

		  }
		  else{
		  	query = "SELECT data AS profiles, schemeGenes FROM datasets.profiles WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t');" +
		  			"SELECT data AS isolates, metadata FROM datasets.isolates WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;" +
		  			"SELECT key FROM datasets.datasets WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;" +
		  			"SELECT data AS links FROM datasets.links WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;";
		  }

		    client.query(query, function(err, result) {
			    if(err) {
			      return console.error('error running query', err);
			    }

				var dataset = {};
				dataset.profiles = [];

			    for(i in result.rows){
			    	for(x in result.rows[i]){
			    		if( x == 'profiles') {
			    			dataset.profiles = dataset.profiles.concat(result.rows[i][x]['profiles']);//JSON.parse(JSON.stringify(result.rows[i][x]['profiles']).replace(/&39/g, "'"));
			    			if (result.rows[i][x].hasOwnProperty('indexestoremove')) dataset.indexestoremove = result.rows[i][x]['indexestoremove'];//JSON.parse(JSON.stringify(result.rows[i][x]['indexestoremove']).replace(/&39/g, "'"));
			    			if (result.rows[i][x].hasOwnProperty('profilesize')) dataset.profilesize = result.rows[i][x]['profilesize'];
			    		}
			    		else if( x  == 'links'){
			    			dataset.links = result.rows[i][x]['links'];
			    			dataset.missings = result.rows[i][x]['missings'];
			    		}
			    		else if( x  == 'isolates') dataset.isolates = result.rows[i][x]['isolates'];
			    		else if( x == 'schemegenes' || x == 'metadata' || x == 'key') dataset[x] = result.rows[i][x].toString().replace(/&39/g, "'").split(',');
			    	}
			    }

			    //dataset.links = [];
			    dataset.datasetID = datasetID;
			    dataset.positions = {};

			    client.end();
			    callback([dataset]);
			});

		});

}

function getLinks(datasetID, userID, isPublic, callback) {

	var pg = require("pg");
	var connectionString = "postgres://" + config.databaseUserString + "@localhost/"+ config.db;

	//var datasetID;

	//query = "SELECT id FROM datasets.datasets WHERE dataset_id = '"+datasetID+"' AND user_id=$1;";

	var client = new pg.Client(connectionString);
		client.connect(function(err) {
		  if(err) {
		    return console.error('could not connect to postgres', err);
		  }
		  if(isPublic == true) query = "SELECT data AS links FROM datasets.links WHERE dataset_id='"+datasetID+"' LIMIT 1;";
		  else query = "SELECT data AS links FROM datasets.links WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;";

		    client.query(query, function(err, result) {
			    if(err) {
			      return console.error('error running query', err);
			    }

				var dataset = {};

			    for(i in result.rows){
			    	for(x in result.rows[i]){
			    		if( x  == 'links'){
			    			dataset.links = result.rows[i][x]['links'];
			    			dataset.missings = result.rows[i][x]['missings'];
			    		}
			    	}
			    }

			    dataset.profiles = [];
			    dataset.isolates = [];
			    dataset.positions = {};


			    client.end();
			    callback([dataset]);
			});

		});

}

function getMetadata(datasetID, userID, isPublic, callback) {

	var pg = require("pg");
	var connectionString = "postgres://" + config.databaseUserString + "@localhost/"+ config.db;

	//var datasetID;

	//query = "SELECT id FROM datasets.datasets WHERE dataset_id = '"+datasetID+"' AND user_id=$1;";

	var client = new pg.Client(connectionString);
		client.connect(function(err) {
		  if(err) {
		    return console.error('could not connect to postgres', err);
		  }

		  if(isPublic == true) query = "SELECT data AS isolates, metadata FROM datasets.isolates WHERE dataset_id='"+datasetID+"' LIMIT 1;";
		  else query = "SELECT data AS isolates, metadata FROM datasets.isolates WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;";


		  //console.log(query);
		    client.query(query, function(err, result) {
			    if(err) {
			      return console.error('error running query', err);
			    }

				var dataset = {};

			    for(i in result.rows){
			    	for(x in result.rows[i]){
			    		if( x  == 'isolates') dataset.isolates = JSON.parse(JSON.stringify(result.rows[i][x]['isolates']).replace(/&39/g, "'"));
			    		else if(x == 'metadata') dataset[x] = result.rows[i][x].toString().replace(/&39/g, "'").split(',');
			    	}
			    }

			    client.end();
			    callback([dataset]);
			});

		});

}

function getAux(datasetID, userID, isPublic, callback) {

	var pg = require("pg");
	var connectionString = "postgres://" + config.databaseUserString + "@localhost/"+ config.db;

	//var datasetID;

	//query = "SELECT id FROM datasets.datasets WHERE dataset_id = '"+datasetID+"' AND user_id=$1;";

	var client = new pg.Client(connectionString);
		client.connect(function(err) {
		  if(err) {
		    return console.error('could not connect to postgres', err);
		  }
		  if(isPublic == true){
		  	query = "SELECT name, key, data_type FROM datasets.datasets WHERE dataset_id='"+datasetID+"' LIMIT 1;" +
		  			"SELECT schemeGenes FROM datasets.profiles WHERE dataset_id='"+datasetID+"';";
		  }
		  else{
		  	query = "SELECT name, key, data_type FROM datasets.datasets WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;" +
		  			"SELECT schemeGenes FROM datasets.profiles WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t');";
		  }

		    client.query(query, function(err, result) {
			    if(err) {
			      return console.error('error running query', err);
			    }

				var dataset = {};

			    for(i in result.rows){
			    	for(x in result.rows[i]){
			    		if( x  == 'name' || x == 'key' || x == 'schemegenes' || x == 'data_type') dataset[x] = result.rows[i][x].toString().replace(/&39/g, "'").split(',');
			    	}
			    }
			    dataset.profiles = [];
			    dataset.isolates = [];
			    dataset.links = [];
			    dataset.positions = {};

			    client.end();
			    callback([dataset]);
			});

		});

}

function getPositions(datasetID, userID, isPublic, callback) {

	var pg = require("pg");
	var connectionString = "postgres://" + config.databaseUserString + "@localhost/"+ config.db;

	//var datasetID;

	//query = "SELECT id FROM datasets.datasets WHERE dataset_id = '"+datasetID+"' AND user_id=$1;";

	var client = new pg.Client(connectionString);
		client.connect(function(err) {
		  if(err) {
		    return console.error('could not connect to postgres', err);
		  }
		  if(isPublic == true) query = "SELECT data AS positions FROM datasets.positions WHERE dataset_id='"+datasetID+"' LIMIT 1;";
		  else query = "SELECT data AS positions FROM datasets.positions WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;";

		    client.query(query, function(err, result) {
			    if(err) {
			      return console.error('error running query', err);
			    }

				var dataset = {};

			    for(i in result.rows){
			    	for(x in result.rows[i]){
			    		if( x  == 'positions') dataset.positions = result.rows[i][x];
			    	}
			    }

			    dataset.profiles = [];
			    dataset.isolates = [];
			    dataset.links = [];

			    client.end();
			    callback([dataset]);
			});

		});

}

function getNewick(datasetID, userID, isPublic, callback) {

	var pg = require("pg");
	var connectionString = "postgres://" + config.databaseUserString + "@localhost/"+ config.db;

	//var datasetID;

	//query = "SELECT id FROM datasets.datasets WHERE dataset_id = '"+datasetID+"' AND user_id=$1;";

	var client = new pg.Client(connectionString);
		client.connect(function(err) {
		  if(err) {
		    return console.error('could not connect to postgres', err);
		  }
		  if(isPublic == true) query = "SELECT data AS newick FROM datasets.newick WHERE dataset_id='"+datasetID+"' LIMIT 1;";
		  else query = "SELECT data AS newick FROM datasets.newick WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;";

		    client.query(query, function(err, result) {
			    if(err) {
			      return console.error('error running query', err);
			    }

				var dataset = {};

			    for(i in result.rows){
			    	for(x in result.rows[i]){
			    		if( x  == 'newick') dataset.newick = result.rows[i][x]['newick'];
			    	}
			    }

			    client.end();
			    callback([dataset]);
			});

		});

}

function getDataset(datasetID, userID, isPublic, callback) {

	var pg = require("pg");
	var connectionString = "postgres://" + config.databaseUserString + "@localhost/"+ config.db;

	//var datasetID;

	//query = "SELECT id FROM datasets.datasets WHERE dataset_id = '"+datasetID+"' AND user_id=$1;";

	var client = new pg.Client(connectionString);
		client.connect(function(err) {
		  if(err) {
		    return console.error('could not connect to postgres', err);
		  }

		  if(isPublic == true){

		  	query = "SELECT data AS profiles, schemeGenes FROM datasets.profiles WHERE dataset_id='"+datasetID+"';" +
		    		"SELECT data AS isolates, metadata FROM datasets.isolates WHERE dataset_id='"+datasetID+"' LIMIT 1;" +
		    		"SELECT data AS links FROM datasets.links WHERE dataset_id='"+datasetID+"' LIMIT 1;" +
		    		//"SELECT distanceMatrix FROM datasets.links WHERE dataset_id='"+datasetID+"' LIMIT 1;" +
		    		"SELECT data AS newick FROM datasets.newick WHERE dataset_id='"+datasetID+"' LIMIT 1;" +
		    		"SELECT data AS positions FROM datasets.positions WHERE dataset_id='"+datasetID+"' LIMIT 1;" +
		    		"SELECT name, key, data_type FROM datasets.datasets WHERE dataset_id='"+datasetID+"' LIMIT 1;";

		  }
		  else{

		    query = "SELECT data AS profiles, schemeGenes FROM datasets.profiles WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t');" +
		    		"SELECT data AS isolates, metadata FROM datasets.isolates WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;" +
		    		"SELECT data AS links FROM datasets.links WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;" +
		    		//"SELECT distanceMatrix FROM datasets.links WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;" +
		    		"SELECT data AS newick FROM datasets.newick WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;" +
		    		"SELECT data AS positions FROM datasets.positions WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;" +
		    		"SELECT name, key, data_type FROM datasets.datasets WHERE (dataset_id='"+datasetID+"' AND user_id='"+userID+"') OR (dataset_id='"+datasetID+"' AND is_public='t') LIMIT 1;";
		  }

		  //console.log(query);


		    client.query(query, function(err, result) {
			    if(err) {
			      return console.error('error running query', err);
			    }

				var dataset = {};
				dataset.profiles = [];

			    for(i in result.rows){
			    	for(x in result.rows[i]){
			    		if( x == 'profiles') {
			    			dataset.profiles = dataset.profiles.concat(result.rows[i][x]['profiles']);//JSON.parse(JSON.stringify(result.rows[i][x]['profiles']).replace(/&39/g, "'"));
			    			if (result.rows[i][x].hasOwnProperty('indexestoremove')) dataset.indexestoremove = result.rows[i][x]['indexestoremove'];//JSON.parse(JSON.stringify(result.rows[i][x]['indexestoremove']).replace(/&39/g, "'"));
			    			if (result.rows[i][x].hasOwnProperty('profilesize')) dataset.profilesize = result.rows[i][x]['profilesize'];
			    		}
			    		else if( x  == 'isolates') dataset.isolates = result.rows[i][x]['isolates'];
			    		else if( x  == 'links'){
			    			dataset.links = result.rows[i][x]['links'];
			    			dataset.missings = result.rows[i][x]['missings'];
			    		}
			    		else if( x  == 'distancematrix'){
			    			try{
			    				dataset.distanceMatrix = result.rows[i][x]['distanceMatrix'];
			    			}
			    			catch (TypeError){
			    				dataset.distanceMatrix = {};
			    			}
			    		} 
			    		else if( x  == 'newick') dataset.newick = result.rows[i][x]['newick'];
			    		else if( x  == 'positions') dataset.positions = result.rows[i][x];
			    		else if( x  == 'name' || x == 'key' || x == 'schemegenes' || x == 'metadata' || x == 'data_type') dataset[x] = result.rows[i][x].toString().replace(/&39/g, "'").split(',');
			    	}
			    }
			    client.end();
			    callback([dataset]);
			});

		});
}

function addToFilterTable(graph, userID, datasetID, overrideArray, callback){

	if(!graph.hasOwnProperty('mergedNodes')) return callback();

	var pg = require("pg");
	var connectionString = "pg://" + config.databaseUserString + "@localhost/"+ config.db;

	var dataToSave = {};

	if (overrideArray.length != 0) var KeysToSave = overrideArray;
	else var KeysToSave = ['mergedNodes', 'sameProfileHas', 'sameNodeHas', 'subsetProfiles', 'usedLoci', 'nodes', 'goeburstprofilesize', 'missingsInfo', 'distanceMatrix'];
	var lengthOfKeys = KeysToSave.length;

	var client = new pg.Client(connectionString);
	
	var NodesToSplice = graph['nodes'].slice(0, graph['nodes'].length);
	var SubsetNodesToSplice = graph['subsetProfiles'].slice(0, graph['subsetProfiles'].length);
	var MatrixToSplice = graph['distanceMatrix'].slice(0, graph['distanceMatrix'].length);

    client.connect(function(err) {
    	if(err) {
		    data.hasError = true;
		    data.errorMessage = 'Could not connect to database.'; //+ err.toString();
		    return callback(data);
  		}
  		index = 0;

  		if (overrideArray.length != 0){
  			var toDelete = [];
  			var query = "SELECT id, data FROM datasets.filters WHERE dataset_id=$1;";
  			client.query(query, [datasetID], function(err, result) {
	            if(err) {
	             // data.hasError = true;
	              console.log(err);
	              data.errorMessage = 'Could not upload input data. Possible unsupported file type. For information on supported file types click <a href="/index/inputinfo">here</a>.'; //+ err.toString();
	              return callback(data);
	            }

	            for(row in result.rows){
	            	var resultObject = result.rows[row].data == undefined ? result.rows[row] : result.rows[row].data;
			    	//console.log(resultObject);
			    	var keyT = Object.keys(resultObject)[0];
		    		if(overrideArray.indexOf(keyT) > -1){
		    			toDelete.push(result.rows[row].id);
		    		}
			    	
			    }

			    var deleteIndex = 0;
			    
			    function deleteFromArray(){
			    	if(deleteIndex < toDelete.length){

			    		var query = "DELETE FROM datasets.filters WHERE id=$1;";

			    		client.query(query, [toDelete[deleteIndex]], function(err, result) {
				            if(err) {
				             // data.hasError = true;
				              console.log(err);
				              data.errorMessage = 'Could not upload input data. Possible unsupported file type. For information on supported file types click <a href="/index/inputinfo">here</a>.'; //+ err.toString();
				              return callback(data);
				            }
							deleteIndex += 1;
				            deleteFromArray();

				        });

			    	}
			    	else runQuery(index);
			    }

			    deleteFromArray();

	        });
  		}
  		else runQuery(index);
  		
  		function runQuery(index){

  			keyToUse = KeysToSave[index];
  			query = '';
  			dataToUse = {};

  			var query = "INSERT INTO datasets.filters (user_id, dataset_id, data, data_timestamp) VALUES ('"+userID+"', '"+datasetID+"', $1, NOW());";

  			if(keyToUse == 'nodes'){
  				dataToUse[keyToUse] = NodesToSplice.splice(0, config.batchSize);
  			}
  			else if(keyToUse == 'subsetProfiles'){
  				dataToUse[keyToUse] = SubsetNodesToSplice.splice(0, config.batchSize);
  			}
  			else if(keyToUse == 'distanceMatrix'){
  				dataToUse[keyToUse] = MatrixToSplice.splice(0, config.batchSize);
  			}
  			else dataToUse[keyToUse] = graph[keyToUse];

  			client.query(query, [dataToUse], function(err, result) {
	            if(err) {
	             // data.hasError = true;
	              console.log(err);
	              data.errorMessage = 'Could not upload input data. Possible unsupported file type. For information on supported file types click <a href="/index/inputinfo">here</a>.'; //+ err.toString();
	              return callback(data);
	            }

	            if(keyToUse == 'nodes' && NodesToSplice.length == 0 || keyToUse == 'subsetProfiles' && SubsetNodesToSplice.length == 0 || keyToUse == 'distanceMatrix' && MatrixToSplice.length == 0) index += 1;
	            else if(keyToUse != 'nodes' && keyToUse != 'subsetProfiles' && keyToUse != 'distanceMatrix') index += 1;

	            if(lengthOfKeys == index) return callback();
	            
	            runQuery(index);

	        });
  		}
  		
  	});
}

function getFromFilterTable(dataset_id, callback){

	var graph = {};

	var pg = require("pg");
	var connectionString = "pg://" + config.databaseUserString + "@localhost/"+ config.db;

	var client = new pg.Client(connectionString);
		
	client.connect(function(err) {
	  if(err) {
	    return console.error('could not connect to postgres', err);
	  }

		query = "SELECT data FROM datasets.filters WHERE dataset_id = '"+dataset_id+"';" +
				"SELECT key FROM datasets.datasets WHERE dataset_id='"+dataset_id+"' LIMIT 1;";
		
		client.query(query, function(err, result) {
		    if(err) {
		      return console.error('error running query', err);
		    }

		    graph.nodes = [];

		    for(row in result.rows){
		    	var resultObject = result.rows[row].data == undefined ? result.rows[row] : result.rows[row].data;
		    	//console.log(resultObject);
		    	var keyT = Object.keys(resultObject)[0];
		    	if(keyT == 'nodes' || keyT == 'subsetProfiles' || keyT == 'distanceMatrix'){
		    		if(!graph.hasOwnProperty(keyT)) graph[keyT] = [];
		    		graph[keyT] = graph[keyT].concat(resultObject[keyT]);

		    	}
		    	else if(keyT == 'key') graph[keyT] = [resultObject[keyT]];
		    	else graph[keyT] = resultObject[keyT];
		    }

		    callback(graph);
		});
	});

}

function FlushFunction(graphInput, res, callback){

	//res.setMaxListeners(0); //set listerners to infinity

		var iterCount = 0;
		var maxCount = 0;

		function populateArray(dataString, timeO, callback) {

		    send(dataString, timeO, function(){
		    	callback();
		    });
		}

		function send(dataString, timeO, callback) {

		  	setTimeout(function(){
		  		write_to_client(function(){
		  			callback();
		  		});
		  	}, timeO);

		    function write_to_client(callback){
		  	  res.write("data: " + dataString + '\n\n');
		      res.flush(function() { // <--------- callback to flush which on invocation resumes the array population
			    callback();
		        //populateArray(++iterCount);

		    });
		  }
		}

		var counts = 0;
		var arrayOfKeys = Object.keys(graphInput);
		var numKeys = arrayOfKeys.length;
		var toAdd = '';

		var batches = 0;
		//var doneBatches = 0;
		//var profileLength = graphInput.nodes[0].profile.length;

		maxCount = numKeys;

		res.setHeader('Content-Type', 'text/event-stream')
		res.setHeader('Cache-Control', 'no-cache')
		

		function runFlush(index){
			console.log(arrayOfKeys[index]);
			//arrayOfKeys[index] == 'nodes' || arrayOfKeys[index] == 'subsetProfiles' || 
			if(arrayOfKeys[index] == 'links'){
				if(graphInput[arrayOfKeys[index]].length != 0){
					batches += 1;
					//console.log('BATCH ', batches);
					var nodeSlice = graphInput[arrayOfKeys[index]].splice(0, 1); //config.batchSize
					nodeLength = nodeSlice.length;
					var toSend = '{"' + arrayOfKeys[index] + '":' + JSON.stringify(nodeSlice) + '}';

					if (arrayOfKeys[index] == 'distanceMatrix' && nodeLength > 7000) var tout = 700;
					else if (arrayOfKeys[index] == 'distanceMatrix' && nodeLength > 6000) var tout = 600;
					else if (arrayOfKeys[index] == 'distanceMatrix' && nodeLength > 5000) var tout = 500;
					else if (arrayOfKeys[index] == 'distanceMatrix' && nodeLength > 4000) var tout = 400;
					else if (arrayOfKeys[index] == 'distanceMatrix' && nodeLength > 3000) var tout = 300;
					else if (arrayOfKeys[index] == 'distanceMatrix' && nodeLength > 2000) var tout = 200;
					else if (arrayOfKeys[index] == 'distanceMatrix' && nodeLength < 2000) var tout = 100;
					else var tout = 10;
  					
  					populateArray(toSend, tout, function(){
  						//if (arrayOfKeys[index] == 'distanceMatrix') index += 1;
						runFlush(index);
					});
				}
				else{
					index += 1;
					runFlush(index);
				}

			}
			//arrayOfKeys[index] == 'usedLoci'
			/*
			else if(arrayOfKeys[index] == 'mergedNodes' || arrayOfKeys[index] == 'sameNodeHas'){

				if(graphInput[arrayOfKeys[index]] == undefined){
					index += 1;
					runFlush(index);
				}
				else if(Object.keys(graphInput[arrayOfKeys[index]]).length != 0){
					batches += 1;
					//console.log('BATCH ', batches);
					propertyToUse = Object.keys(graphInput[arrayOfKeys[index]])[0];
					//console.log(propertyToUse);
					var nodeSlice = {};

					if(arrayOfKeys[index] == 'indexesToRemove'){
		              graphInput[arrayOfKeys[index]][propertyToUse] = graphInput[arrayOfKeys[index]][propertyToUse] == true ? "true" : "false";
		              //console.log()
		            }
					nodeSlice[propertyToUse] = graphInput[arrayOfKeys[index]][propertyToUse]; //config.batchSize
					//nodeLength = nodeSlice.length;
					var toSend = '{"' + arrayOfKeys[index] + '":' + JSON.stringify(nodeSlice) + '}';

					var tout = 50;

  					populateArray(toSend, tout, function(){
  						delete graphInput[arrayOfKeys[index]][propertyToUse];
						runFlush(index);
					});
				}
				else{
					index += 1;
					runFlush(index);
				}
			}
			*/
			else if(arrayOfKeys[index] == 'distanceMatrix' || arrayOfKeys[index] == 'usedLoci' ||arrayOfKeys[index] == 'indexesToRemove' || arrayOfKeys[index] == 'mergedNodes' || arrayOfKeys[index] == 'sameNodeHas'){
				index += 1;
				runFlush(index);
			}
			else{
				//console.log(arrayOfKeys[index]);
				var toSend = '{"' + arrayOfKeys[index] + '":' + JSON.stringify(graphInput[arrayOfKeys[index]]) + '}';

				//var toSend = '{"' + arrayOfKeys[index] + '":' + JSON.stringify({}) + '}';
				var tout = 1;

				populateArray(toSend, tout, function(){
					index += 1;
					if(index < numKeys) runFlush(index);
					else{
				      res.end();
				      return;
					    
					}
				});

			}
			
		}

		runFlush(0);

}

function mergeMetadata(graphInput, newMetadata, callback) {

	var nodes = graphInput.nodes;
	var sameNodeHas = graphInput.sameNodeHas;
	//console.log(sameNodeHas);
	var key = graphInput.key[0];
	var metadata = newMetadata.metadata;

	for(i in nodes){
		nodeKey = nodes[i].key;
		for(k in newMetadata.isolates) {
			var isolate = newMetadata.isolates[k];
			if(sameNodeHas[isolate[key]] == nodeKey){
				var toIsolates = metadata.map(function(locus){
					return isolate[locus];
				})
				nodes[i].isolates.push(toIsolates);
			}
		}
	}
	graphInput.metadata = newMetadata.metadata || []; 
	callback(graphInput);
}

module.exports = function(config){
	return utils_object;
}



function createProfileInput(dataset, callback){

	if (Object.keys(dataset).length == 0) {
		callback({error: 'Dataset does not exists.'});
		return false;
	}
	
	var linksToUse = dataset.links;
	
	var graph = {};
	var nodes = {};
	var links = [];
	var existsProfile = {};
	var profileKey = {};
	var sameProfileHas = {};


	checkNodes(dataset, function(error){
		checkIsolates(dataset, function(){
			checkLinks(linksToUse, function(){
				
				graph.nodes = Object.keys(nodes).map(function(k) { return nodes[k] }); // nodeObject to array
				graph.links = links;
				
				graph.schemeGenes = dataset.schemegenes;
				
				graph.metadata = dataset.metadata;
				graph.key = dataset.key;
				graph.data_type = dataset.data_type;
				graph.dataset_name = dataset.name;
				graph.sequences = dataset.sequences;
				graph.indexesToRemove = dataset.indexestoremove;
				graph.missingsInfo = dataset.missings;
				graph.goeburstprofilesize = dataset.profilesize;
				
				//if(Object.keys(dataset.distanceMatrix).length == 0) graph.distanceMatrix = {}; //graph.positions = JSON.parse(dataset.positions);
				//else graph.distanceMatrix = dataset.distanceMatrix;

				if(Object.keys(dataset.positions).length == 0) graph.positions = {}; //graph.positions = JSON.parse(dataset.positions);
				else graph.positions = dataset.positions;

				if(graph.nodes.length != 0 && (graph.nodes.length > 2000 || graph.schemeGenes.length > 1000)){

					create_subset_profile(graph, function(graph){
						graph.schemeGenes = [];
						callback(graph);
					})
				}
				else callback(graph);

				//getMissingData(dataset.profiles, function(missingData){
				//  graph.missingData = missingData;
                //  callback(graph);
                //});
				
			});
		});
	});

	function checkNodes(dataset, callback){

		dataset.profiles.forEach(function(profile){
			var sequence = "";
			var profileToUse = "";
			if(dataset.data_type == 'fasta'){
		    	profileToUse = profile.profile;
		    	sequence = profile.sequence;
		    }
		    else{
		    	profileToUse = profile;
		    }
			var arr = [];
			for (i in dataset.schemegenes) arr.push(profileToUse[dataset.schemegenes[i]]);
			//var arr = Object.keys(profile).map(function(k) { return profile[k] });
			var key = arr.shift();
			//arr = arr.reverse();
			var node = {key: key, profile: arr, isolates: [], sequence: sequence};

			
			if(existsProfile[String(arr)]) {
				sameProfileHas[String(key)] = profileKey[String(arr)];
				//console.log('profile already exists');
			}
			else{
				profileKey[String(arr)] = key;
				existsProfile[String(arr)] = true;
				nodes[key] = node;
			}
			
		});

		callback();
	}

	function checkIsolates(dataset, callback){

		dataset.isolates.forEach(function(isolate){

			if (sameProfileHas.hasOwnProperty(isolate[dataset.key])){
				isolate[dataset.key] = sameProfileHas[isolate[dataset.key]];
			}

			if(nodes[isolate[dataset.key]]){
				var arr = [];
				for (i in dataset.metadata) arr.push(isolate[dataset.metadata[i]]);
				//var arr = Object.keys(isolate).map(function(k) { return isolate[k]; });
			}

			try{
				nodes[isolate[dataset.key]].isolates.push(arr);
			}
			catch (err){
				var x = true;
			}
			
		});

		callback();
	}

	function checkLinks(linksToUse, callback){

		linksToUse.forEach(function(link){
			links.push({source: link.source, target: link.target, value: link.value});
		});

		callback();
	}
}


function create_subset_profile(graph, callback){

	var newProfiles = [];
    var newProfile = [];
    var indexToRemove = {};
    var exportAllProfileObject = {};
    var sameProfileHas1 = {};
    var sameNodeHas = {};
    var mergedNodes = {};

    var newNodes = [];
    
    var usedLoci = {};

    //if(!graph.hasOwnProperty('indexesToRemove')) return callback(graph);

	var nodes = graph.nodes;
	var links = graph.links;
	
	for(i in nodes){
		profile = nodes[i].profile;

		var newProfile = [];
		var countPosition = -1;

		exportAllProfileObject[nodes[i].key] = [];

		for(position in profile){
			countPosition++;
			if(graph.hasOwnProperty('indexesToRemove') && graph.indexesToRemove != undefined){
				if(!graph.indexesToRemove.hasOwnProperty(countPosition)){
					usedLoci[graph.schemeGenes[countPosition+1]] = countPosition;
					newProfile.push(profile[position]);
					exportAllProfileObject[nodes[i].key].push({gene: graph.schemeGenes[countPosition+1], value:profile[position]});
				}
			}
			else newProfile = profile;
		}

		if(!sameProfileHas1[String(newProfile)]){
			if(newNodes.length == 0) nodeIndex = 0;
			else nodeIndex = newNodes.length - 1;
			mergedNodes[nodes[i].key] = [];
			sameProfileHas1[String(newProfile)] = [nodes[i].key, nodeIndex];
			sameNodeHas[nodes[i].key] = nodes[i].key;
			newNodes.push(nodes[i]);
			newProfiles.push({profile: newProfile});
		}
		else{
			mergedNodes[sameProfileHas1[String(newProfile)][0]].push(nodes[i]);
			sameNodeHas[nodes[i].key] = sameProfileHas1[String(newProfile)][0];
			newNodes[sameProfileHas1[String(newProfile)][1]].isolates = newNodes[sameProfileHas1[String(newProfile)][1]].isolates.concat(nodes[i].isolates);
		}
	}
	var newLinks = [];

	for(j in links){
		if(links[j].value != 0){
			links[j].source = sameNodeHas[links[j].source];
			links[j].target = sameNodeHas[links[j].target];
			newLinks.push(links[j]);
		}
	}
	graph.mergedNodes = mergedNodes;
	graph.links = newLinks;
	graph.nodes = newNodes;
	graph.sameProfileHas = sameProfileHas1;
	graph.sameNodeHas = sameNodeHas;
	graph.subsetProfiles = newProfiles;
	graph.usedLoci = usedLoci;
	//graph.goeBURSTprofileExport = exportAllProfileObject;
	callback(graph);

}


function getMissingData(data, callback){

  var profiles = data.map(function(k) { 
    var arrayToUse = Object.keys(k).map(function(z){
                    return k[z];
                  }); 

    return arrayToUse.slice(1,arrayToUse.length);
  });

  var missingDataArray = profiles.map(function(d,i){
    var countMissing = 0;
    d.map(function(x){
      if (x == "-" || x =="") countMissing += 1;
    });
    return countMissing;
  });

  callback(missingDataArray);



}


module.exports = function(dataset, callback){

	createProfileInput(dataset, function(graph){
		callback(graph);
	});
}
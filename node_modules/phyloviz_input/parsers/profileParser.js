
function createProfileInput(dataset, callback){
	
	var linksToUse = dataset.links;
	
	var graph = {};
	var nodes = {};
	var links = [];
	var existsProfile = {};
	var profileKey = {};
	var sameProfileHas = {};

	checkNodes(dataset, function(){
		checkIsolates(dataset, function(){
			checkLinks(linksToUse, function(){
				
				graph.nodes = Object.keys(nodes).map(function(k) { return nodes[k] }); // nodeObject to array
				graph.links = links;
				graph.schemeGenes = dataset.schemeGenes;
				graph.metadata = dataset.metadata;

				if(dataset.positions) graph.positions = JSON.parse(dataset.positions);
				else graph.positions = {};
				
				callback(graph);
			});
		});
	});

	function checkNodes(dataset, callback){

		dataset.profiles.forEach(function(profile){
			var arr = Object.keys(profile).map(function(k) { return profile[k] });
			var key = arr.pop();
			arr = arr.reverse();

			var node = {key: key, profile: arr, isolates: []};

			
			if(existsProfile[String(arr)]) {
				sameProfileHas[String(key)] = profileKey[String(arr)];
			}
			
			else{
				profileKey[String(arr)] = key;
				existsProfile[String(arr)] = true;
				nodes[key] = node;
			}
		});

		callback();
	}

	function checkIsolates(dataset, callback){

		dataset.isolates.forEach(function(isolate){

			if (sameProfileHas.hasOwnProperty(isolate[dataset.key])){
				isolate[dataset.key] = sameProfileHas[isolate[dataset.key]];
			}

			if(nodes[isolate[dataset.key]]){
				var arr = Object.keys(isolate).map(function(k) { return isolate[k]; });
			}

			try{
				nodes[isolate[dataset.key]].isolates.push(arr.reverse());
			}
			catch (err){
				var x = true;
			}
			
		});

		callback();
	}

	function checkLinks(linksToUse, callback){

		linksToUse.forEach(function(link){
			links.push({source: link.source, target: link.target, value: link.value});
		});

		callback();
	}
}

module.exports = function(dataset, callback){

	createProfileInput(dataset, function(graph){
		callback(graph);
	});
}
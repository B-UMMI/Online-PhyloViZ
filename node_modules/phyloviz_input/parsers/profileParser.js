
function createProfileInput(dataset, callback){

	if (Object.keys(dataset).length == 0) {
		callback({error: 'Dataset does not exists.'});
		return false;
	}
	
	var linksToUse = dataset.links;
	
	var graph = {};
	var nodes = {};
	var nodesArray = [];
	var links = [];
	var existsProfile = {};
	var profileKey = {};
	var sameProfileHas = {};

	pres_abs_replace(dataset, function(){
		checkNodes(dataset, function(error){
			checkIsolates(dataset, function(){
				checkLinks(linksToUse, function(){
					
					//graph.nodes = Object.keys(nodes).map(function(k) { return nodes[k] }); // nodeObject to array
					graph.nodes = nodesArray;
					graph.links = links;
					
					graph.schemeGenes = dataset.schemegenes;

					graph.maxDistanceValue = dataset.maxDistanceValue;
					graph.metadata = dataset.metadata;
					graph.key = dataset.key;
					graph.data_type = dataset.data_type;
					graph.dataset_name = dataset.name;
					graph.sequences = dataset.sequences;
					graph.indexesToRemove = dataset.indexestoremove;
					graph.missingsInfo = dataset.missings;
					graph.goeburstprofilesize = dataset.profilesize;
					graph.datasetID = dataset.datasetID;
					graph.goeburst_timer = dataset.goeburst_timer;
					graph.timestamp = dataset.data_timestamp;
					graph.parent_id = dataset.parent_id;
					graph.analysis_method = dataset.analysis_method;
					graph.missing_threshold = dataset.missing_threshold;


					if(Object.keys(dataset.positions).length == 0) graph.positions = {}; //graph.positions = JSON.parse(dataset.positions);
					else graph.positions = dataset.positions;

					if(graph.nodes.length != 0){

						create_subset_profile(graph, function(graph){
							graph.schemeGenes = [];
							callback(graph);
						})
					}
					else callback(graph);
					
				});
			});
		});
	});

	function pres_abs_replace(dataset, callback){

		if(dataset.hasOwnProperty('analysis_method') && dataset.analysis_method == 'pres-abs'){
			dataset.profiles.forEach(function(profile){
				var count = 0;
				Object.keys(profile).forEach(function(position, i){
					if(position == dataset.schemegenes[0]);
					else if(profile[position] != dataset.missings[1]){
						profile[position] = '1';
						count += 1;
					}
					else profile[position] = '0';
				});
			});
			callback();
		}
		else callback();
	}

	function checkNodes(dataset, callback){

		dataset.profiles.forEach(function(profile){
			var sequence = "";
			var profileToUse = "";
			if(dataset.data_type[0] == 'fasta'){

		    	profileToUse = profile.profile;
		    	sequence = profile.sequence;
		    }
		    else{
		    	profileToUse = profile;
		    }

			var arr = [];

			for (i in dataset.schemegenes) arr.push(profileToUse[dataset.schemegenes[i]]);

			var key = arr.shift();

			var node = {key: key, profile: arr, isolates: [], sequence: sequence};

			profileKey[String(arr)] = key;
			existsProfile[String(arr)] = true;
			if(nodes[key] != undefined) console.log(key);
			nodesArray.push(node);
			nodes[key] = node;
			
		});

		callback();
	}

	function checkIsolates(dataset, callback){

		dataset.isolates.forEach(function(isolate){

			if (sameProfileHas.hasOwnProperty(isolate[dataset.key])){
				isolate[dataset.key] = sameProfileHas[isolate[dataset.key]];
			}

			if(nodes[isolate[dataset.key]]){
				var arr = [];
				for (i in dataset.metadata) arr.push(isolate[dataset.metadata[i]]);
			}

			try{
				nodes[isolate[dataset.key]].isolates.push(arr);
			}
			catch (err){
				var x = true;
			}
			
		});

		callback();
	}

	function checkLinks(linksToUse, callback){

		linksToUse.forEach(function(link){
			links.push({source: link.source, target: link.target, value: link.value, missings: link.missings});
		});

		callback();
	}
}

function create_subset_profile(graph, callback){

	var newProfiles = [];
    var newProfile = [];
    var indexToRemove = {};
    var exportAllProfileObject = {};
    var sameProfileHas1 = {};
    var sameNodeHas = {};
    var mergedNodes = {};

    var newNodes = [];
    
    var usedLoci = {};


	var nodes = graph.nodes;
	var links = graph.links;

	console.log("NODES LENGTH", nodes.length);
	
	for(i in nodes){
		profile = nodes[i].profile;

		var newProfile = [];
		var countPosition = -1;

		exportAllProfileObject[nodes[i].key] = [];

		for(position in profile){
			countPosition++;
			if(graph.hasOwnProperty('indexesToRemove') && graph.indexesToRemove != undefined){
				if(!graph.indexesToRemove.hasOwnProperty(countPosition)){
					usedLoci[graph.schemeGenes[countPosition+1]] = countPosition;
					newProfile.push(profile[position]);
					exportAllProfileObject[nodes[i].key].push({gene: graph.schemeGenes[countPosition+1], value:profile[position]});
				}
			}
			else newProfile = profile;
		}

		if(!sameProfileHas1[String(newProfile)]){
			if(newNodes.length == 0) nodeIndex = 0;
			else nodeIndex = newNodes.length;
			nodes[i].position = i;
			mergedNodes[nodes[i].key] = [];
			sameProfileHas1[String(newProfile)] = [nodes[i].key, nodeIndex];
			sameNodeHas[nodes[i].key] = nodes[i].key;
			newNodes.push(nodes[i]);
			newProfiles.push({profile: newProfile});
		}
		else{
			nodes[i].position = i;
			mergedNodes[sameProfileHas1[String(newProfile)][0]].push(nodes[i]);
			sameNodeHas[nodes[i].key] = sameProfileHas1[String(newProfile)][0];
			newNodes[sameProfileHas1[String(newProfile)][1]].isolates = newNodes[sameProfileHas1[String(newProfile)][1]].isolates.concat(nodes[i].isolates);
		}
	}
	var newLinks = [];

	for(j in links){
		if(links[j].value != 0 || links[j].value == 0 && graph.analysis_method != 'core'){
			links[j].source = sameNodeHas[links[j].source];
			links[j].target = sameNodeHas[links[j].target];
			newLinks.push(links[j]);
		}
	}
	graph.mergedNodes = mergedNodes;
	graph.links = newLinks;
	graph.nodes = newNodes;
	graph.sameProfileHas = sameProfileHas1;
	graph.sameNodeHas = sameNodeHas;
	graph.subsetProfiles = newProfiles;
	graph.usedLoci = usedLoci;
	graph.goeBURSTschemeGenesExport = exportAllProfileObject[Object.keys(exportAllProfileObject)[0]];

	callback(graph);

}

module.exports = function(dataset, callback){

	createProfileInput(dataset, function(graph){
		callback(graph);
	});
}
precision mediump float;
varying vec2 vTexCoord; //get the passing value from the vertex shader
uniform int unumberOfParts;
void main(){

	vec4 angles = vec4(100.0, 110.0, 70.0, 30.0);
	float prevAngle = radians(0.0);
	float radQuad = radians(90.0);
	float totalAngles = 0.0;

	bool found = false;
	bool hasRest = false;
	float rad = 0.0;
	float AngleToUse = 0.0;
	float rest;

	if (vTexCoord.y < 0.0 && vTexCoord.x < 0.0){
		for (int i = 0; i<4;i++){
			totalAngles = totalAngles + angles[i];
			if (totalAngles > 90.0){
				rest = totalAngles - 90.0;
				AngleToUse = angles[i] - rest;
				hasRest = true;
			}
			else{
				AngleToUse = angles[i];
			}
			rad = radians(AngleToUse);
			if ((tan(rad + prevAngle) >= (vTexCoord.y) / (vTexCoord.x)) && (tan(prevAngle) <= (vTexCoord.y) / (vTexCoord.x))){
				float color = float(i) * 0.3;
				if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
					//gl_FragColor = vec4(1, 0, 0, 1);
						 	
						 		gl_FragColor = vec4(color, 0, 0, 1);
						 		found = true;

				}	
			}
			prevAngle = prevAngle + rad;
			if (totalAngles > 90.0){
				break;
			}
		}

	}

	else if (vTexCoord.y < 0.0 && vTexCoord.x > 0.0){
		for (int i = 0; i<4;i++){
			totalAngles = totalAngles + angles[i];
			if (totalAngles >= 90.0){
				if (totalAngles - angles[i] < 90.0){
					AngleToUse = totalAngles - 90.0;
				}
				else if (totalAngles > 180.0){
					rest = totalAngles - 180.0;
					AngleToUse = angles[i] - rest;
					hasRest = true;
				}
				else{
					AngleToUse = angles[i];
				}

				rad = radians(AngleToUse);
			 	 if ((tan(radQuad - (rad + prevAngle)) <= (vTexCoord.y) / -(vTexCoord.x)) && (tan(radQuad - (prevAngle)) >= (vTexCoord.y) / -(vTexCoord.x))){
			 	 	float color = float(i) * 0.3;
			 	 	if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
			 	 		//gl_FragColor = vec4(1, 0, 0, 1);
							 	
			 	 			 		gl_FragColor = vec4(color, 0, 0, 1);
			 	 			 		found = true;

			 	 	}	
			 	 }
			 	 prevAngle = prevAngle + rad;
			 	 if (totalAngles > 180.0){
					break;
				 }

			} 
		}
	}

	 else if (vTexCoord.y > 0.0 && vTexCoord.x > 0.0){
	  	for (int i = 0; i<4;i++){
	  		totalAngles = totalAngles + angles[i];
	  		if (totalAngles >= 180.0){
	  			if (totalAngles - angles[i] < 180.0){
	  				AngleToUse = totalAngles - 180.0;
	  			}
	  			else if (totalAngles > 270.0){
					rest = totalAngles - 270.0;
					AngleToUse = angles[i] - rest;
					hasRest = true;
				}
	  			else{
	  				AngleToUse = angles[i];
	  			}

	  			rad = radians(AngleToUse);
	  		 	if ((tan(rad + prevAngle) >= (vTexCoord.y) / (vTexCoord.x)) && (tan(prevAngle) <= (vTexCoord.y) / (vTexCoord.x))){
	 				float color = float(i) * 0.3;
	 				if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
	 					//gl_FragColor = vec4(1, 0, 0, 1);
							 	
	 						 		gl_FragColor = vec4(color, 0, 0, 1);
	 						 		found = true;

	 				}	
	 			}
	  		 	 prevAngle = prevAngle + rad;
	  		 	 if (totalAngles > 270.0){
					break;
				 }

	  		} 
	  	}
	  }

	  else if (vTexCoord.y > 0.0 && vTexCoord.x < 0.0){
	 	for (int i = 0; i<4;i++){
	 		totalAngles = totalAngles + angles[i];
	 		if (totalAngles >= 270.0){
	 			if (totalAngles - angles[i] < 270.0){
	 				AngleToUse = totalAngles - 270.0;
	 			}
	 			else{
	 				AngleToUse = angles[i];
	 			}

	 			rad = radians(AngleToUse);
	 		 	 if ((tan((rad + prevAngle)) >= -(vTexCoord.x) / (vTexCoord.y)) && (tan((prevAngle)) <= -(vTexCoord.x) / (vTexCoord.y))){
	 		 	 	float color = float(i) * 0.3;
	 		 	 	if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
	 		 	 		//gl_FragColor = vec4(1, 0, 0, 1);
							 	
	 		 	 			 		gl_FragColor = vec4(color, 0, 0, 1);
	 		 	 			 		found = true;

	 		 	 	}	
	 		 	 }
	 		 	 prevAngle = prevAngle + rad;
	 		 	 if (totalAngles > 360.0){
	 				break;
	 			 }

	 		} 
	 	}
	 }

	

if (found == false){
	if ((vTexCoord.x) * (vTexCoord.x) + (vTexCoord.y) * (vTexCoord.y) < 1.0){
		gl_FragColor = vec4(0, 0, 1, 1);
	}
}
	
}